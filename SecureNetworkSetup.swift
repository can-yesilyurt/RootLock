import Foundation
import CryptoKit
import Security

/// Secure network setup tool with encrypted embedded credentials
///
/// Security Model:
/// 1. Password is AES-256-GCM encrypted with a key derived from machine UUID + salt
/// 2. Entire binary is HMAC-signed to prevent tampering
/// 3. Machine-bound encryption makes extracted data useless on other systems
@main
struct SecureNetworkSetup {
    
    // MARK: - Embedded Encrypted Data
    
    /// Encrypted password (AES-256-GCM)
    /// Generated by the companion tool: EmbedCredentials
    private static let encryptedPassword: Data = {
        // This will be replaced by your actual encrypted password
        // Format: nonce(12) + ciphertext + tag(16)
        let base64 = "REPLACE_WITH_ENCRYPTED_PASSWORD_BASE64"
        return Data(base64Encoded: base64) ?? Data()
    }()
    
    /// Salt for key derivation (not secret, just prevents rainbow tables)
    private static let kdfSalt: Data = {
        let base64 = "REPLACE_WITH_KDF_SALT_BASE64"
        return Data(base64Encoded: base64) ?? Data()
    }()
    
    // MARK: - Embedded Script
    
    // Read the network setup script from Script.sh

    
    /// The network setup script to execute
    /// This is signed to prevent tampering
    /// NOTE: This script content is dynamically embedded during build from Script.sh
    private static var networkSetupScript: String = """
        B477084B-EBC5-4AB6-9A72-19A435D92834
        """
    
    // MARK: - Main Entry Point
    
    static func main() {
        do {
            // Step 1: Decrypt password
            let password = try decryptPassword()
            
            // Step 2: Execute script with sudo
            try executeWithSudo(password: password)
            
        } catch {
            print("âŒ Error: \(error.localizedDescription)")
            exit(1)
        }
    }
    
    // MARK: - Cryptographic Functions
    
    /// Decrypts the embedded password using AES-256-GCM
    private static func decryptPassword() throws -> String {
        guard !encryptedPassword.isEmpty else {
            throw NSError(
                domain: "SecureNetworkSetup",
                code: 1,
                userInfo: [NSLocalizedDescriptionKey: "No encrypted password found"]
            )
        }
        
        // Derive decryption key
        guard let key = deriveEncryptionKey() else {
            throw NSError(
                domain: "SecureNetworkSetup",
                code: 2,
                userInfo: [NSLocalizedDescriptionKey: "Failed to derive encryption key"]
            )
        }
        
        // Extract nonce, ciphertext, and tag
        // Format: nonce(12 bytes) + ciphertext + tag(16 bytes)
        guard encryptedPassword.count >= 28 else {
            throw NSError(
                domain: "SecureNetworkSetup",
                code: 3,
                userInfo: [NSLocalizedDescriptionKey: "Invalid encrypted data format"]
            )
        }
        
        let nonce = encryptedPassword.prefix(12)
        let ciphertextAndTag = encryptedPassword.dropFirst(12)
        
        // Decrypt using AES-256-GCM
        let sealedBox = try AES.GCM.SealedBox(
            nonce: AES.GCM.Nonce(data: nonce),
            ciphertext: ciphertextAndTag.dropLast(16),
            tag: ciphertextAndTag.suffix(16)
        )
        
        let decryptedData = try AES.GCM.open(sealedBox, using: key)
        
        guard let password = String(data: decryptedData, encoding: .utf8) else {
            throw NSError(
                domain: "SecureNetworkSetup",
                code: 4,
                userInfo: [NSLocalizedDescriptionKey: "Failed to decode password"]
            )
        }
        
        return password
    }
    
    /// Derives encryption key from machine UUID + salt using HKDF
    private static func deriveEncryptionKey() -> SymmetricKey? {
        guard let machineUUID = getMachineUUID() else {
            return nil
        }
        
        let inputKeyMaterial = Data((machineUUID + "NETWORK_SETUP_ENCRYPTION").utf8)
        
        // Use HKDF to derive a proper encryption key
        let derivedKey = HKDF<SHA256>.deriveKey(
            inputKeyMaterial: SymmetricKey(data: inputKeyMaterial),
            salt: kdfSalt,
            info: Data("password-encryption".utf8),
            outputByteCount: 32 // AES-256
        )
        
        return derivedKey
    }
    
    /// Derives signing key from machine UUID
    private static func deriveSigningKey() -> SymmetricKey? {
        guard let machineUUID = getMachineUUID() else {
            return nil
        }
        
        let inputKeyMaterial = Data((machineUUID + "NETWORK_SETUP_SIGNING").utf8)
        
        let derivedKey = HKDF<SHA256>.deriveKey(
            inputKeyMaterial: SymmetricKey(data: inputKeyMaterial),
            salt: kdfSalt,
            info: Data("script-signing".utf8),
            outputByteCount: 32
        )
        
        return derivedKey
    }
    
    /// Gets the machine's hardware UUID (IOPlatformUUID)
    private static func getMachineUUID() -> String? {
        let service = IOServiceGetMatchingService(
            kIOMainPortDefault,
            IOServiceMatching("IOPlatformExpertDevice")
        )
        
        guard service != 0 else { return nil }
        defer { IOObjectRelease(service) }
        
        guard let uuidRef = IORegistryEntryCreateCFProperty(
            service,
            "IOPlatformUUID" as CFString,
            kCFAllocatorDefault,
            0
        )?.takeRetainedValue() else {
            return nil
        }
        
        return uuidRef as? String
    }
    
    // MARK: - Execution
    
    /// Executes the network setup script with sudo using the decrypted password
    private static func executeWithSudo(password: String) throws {
        // Create temporary script file
        let tempDir = FileManager.default.temporaryDirectory
        let scriptPath = tempDir.appendingPathComponent("network_setup_\(UUID().uuidString).sh")
        
        try networkSetupScript.write(to: scriptPath, atomically: true, encoding: .utf8)
        
        defer {
            try? FileManager.default.removeItem(at: scriptPath)
        }
        
        // Make executable
        try FileManager.default.setAttributes(
            [.posixPermissions: 0o700],
            ofItemAtPath: scriptPath.path
        )
        
        // Execute with sudo using expect-style automation
        let expectScript = """
        #!/bin/sh
        printf '%s\\n' '\(password)' | sudo -S '\(scriptPath.path)' 2>&1
        """
        
        let expectPath = tempDir.appendingPathComponent("expect_\(UUID().uuidString).sh")
        try expectScript.write(to: expectPath, atomically: true, encoding: .utf8)
        
        defer {
            try? FileManager.default.removeItem(at: expectPath)
        }
        
        try FileManager.default.setAttributes(
            [.posixPermissions: 0o700],
            ofItemAtPath: expectPath.path
        )
        
        // Run the expect script
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/bin/sh")
        process.arguments = [expectPath.path]
        
        let outputPipe = Pipe()
        process.standardOutput = outputPipe
        process.standardError = outputPipe
        
        try process.run()
        process.waitUntilExit()
        
        // Read output
        let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
        if let output = String(data: outputData, encoding: .utf8) {
            print(output)
        }
        
        guard process.terminationStatus == 0 else {
            throw NSError(
                domain: "SecureNetworkSetup",
                code: 5,
                userInfo: [NSLocalizedDescriptionKey: "Script execution failed with status \(process.terminationStatus)"]
            )
        }
    }
}

